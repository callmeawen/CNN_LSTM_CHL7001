# -*- coding: utf-8 -*-
"""CHL7001.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sWkEbIuT6fY0LQVp4oMWG0KVl2J27TN1
"""

!pip install yfinance
!pip install ta



import numpy as np
import pandas as pd
import yfinance as yf
import ta as ta
from ta import add_all_ta_features
from ta.utils import dropna
from ta.volatility import BollingerBands
import tensorflow as tf
from pandas_datareader import data as pdr
import matplotlib.pyplot as plt
import tensorflow as tf
import torch
from tqdm._tqdm_notebook import tqdm_notebook

"""<h1><b>Sample Data set from Apple</h1></b>

Traders use them to study the short-term price movement since they do not prove very useful for long-term investors. They are employed primarily to predict future price levels.
"""

data = yf.download("PG", start="2017-01-01", end="2019-01-01")
data2 = yf.download("SPY", start="2017-01-01", end="2019-01-01")
pd.DataFrame(data)

"""The technical indicators used are Average True Range
(ATR), Bollinger Bands (BB), Force Index (FI), Rate of Change (ROC), Williams percentage
Range (WR), Moving Average Convergence Divergence (MACD), and 5 days moving average
(MA5)
"""

# Clean nan values
df = ta.utils.dropna(data)

# ROC
k=ta.momentum.roc(close=df['Close'],n=5,fillna=True)
k
k.plot()
plt.title('Rate of Change')
plt.show()

# Williams percentage Range (WR)
WR = ta.momentum.WilliamsRIndicator(high=df["High"], low=df["Low"], close=df["Close"],fillna=True)
WR._wr
WR._wr.plot()
plt.title('Williams percentage Range')
plt.show()

# Moving Average Convergence Divergence
# subtracting the 26-period EMA from the 12-period EMA.
macd = ta.trend.MACD(close=df['Close'], n_slow= 26, n_fast=12, n_sign=9, fillna=True)
plt.plot(macd._macd, label='MACD')
plt.plot(macd._macd_signal, label='Signal Line (red)', color='red')
plt.plot(macd._macd_diff, label='Difference (yellow)', color='yellow')
plt.legend(loc=2,prop={'size':11})
plt.grid(True)
plt.title('Moving Averages Convergence Divergence')
plt.show()
# a bullish crossover happens when the MACD crosses above the signal line
# a bearish crossover happens when the MACD crosses below the signal line.

# 5-MA
ma = ta.volatility.bollinger_mavg(close=df['Close'],n=5,fillna=True)
ma
plt.plot(df['Close'],lw=1, label='Closing Prices')
ma.plot(label='5-day MA (red)', color='red')
plt.legend(loc=2,prop={'size':11})
plt.grid(True)
plt.title('Moving Averages')
plt.show()

"""<b><h1>Bollinger Bands</h1></b>"""

low = ta.volatility.bollinger_hband(close=df["Close"],
                                    n=5,
                                    ndev=2,
                                    fillna=True)
#pd.DataFrame(low, columns=["hband"])

high = ta.volatility.bollinger_lband(close=df["Close"],
                                     n=5,
                                     ndev=2,
                                     fillna=True)
pd.concat([low, df["Close"], high],axis=1).plot(grid = True)
plt.title('Bollinger Bands Plot')
low
high

"""<b><h1>ATR</h1></b>"""

atr = ta.volatility.AverageTrueRange(high=df["High"],
                                     low=df["Low"],
                                     close=df["Close"],
                                     fillna=True)
#atr.average_true_range().plot()
atr.average_true_range()

"""<b><h1>Force Index</h1></b>

The force index takes into account the direction of the stock price, the extent of the stock price movement, and the volume. Using these three elements it forms an oscillator that measures the buying and the selling pressure.

Each of these three factors plays an important role in the determination of the force index. For example, a big advance in prices, which is given by the extent of the price movement, shows a strong buying pressure. A big decline in heavy volume indicates a strong selling pressure.
"""

force_index = ta.volume.ForceIndexIndicator(close = df["Close"],
                                            volume=df["Volume"],
                                            fillna=True,
                                            n=13).force_index()
force_index.plot()

# LSTM
aggregate_data = pd.concat([data["Close"],
           data["High"],
           data["Low"],
           data["Volume"],
           data["Open"]],
          # data2["Close"],
          # force_index,
           #atr.average_true_range(),
           #k,
          # WR._wr,
          # ma,
          # low,
          # high,
          # macd._macd],
          axis=1)
#aggregate_data.columns = ["Stock_Close","Stock_High", "Stock_Low", "Stock_Volume", "SPY_Open","SPY", "FI","ATR","ROC","WR","MA","BB_Low","BB_High","MACD"]
ip=aggregate_data.to_numpy()
inputs = ip.reshape(1, 502, 5)







rnn = tf.keras.layers.RNN(
   tf.keras.layers.LSTMCell(1),
   return_sequences=True,
   return_state=True)
whole_seq_output, final_memory_state, final_carry_state = rnn(inputs)
print(whole_seq_output)

tf.keras.layers.LSTM(
    1, activation='tanh', recurrent_activation='sigmoid', use_bias=True,
    kernel_initializer='glorot_uniform', recurrent_initializer='orthogonal',
    bias_initializer='zeros', unit_forget_bias=True, kernel_regularizer=None,
    recurrent_regularizer=None, bias_regularizer=None, activity_regularizer=None,
    kernel_constraint=None, recurrent_constraint=None, bias_constraint=None,
    dropout=0.0, recurrent_dropout=0.0, implementation=2, return_sequences=False,
    return_state=False, go_backwards=False, stateful=False, time_major=False,
    unroll=False)
